<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Biofilm Prediction Tool v8.1</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Nunito:wght@700;800&family=Inter:wght@400;500;600;700&display=swap"
      rel="stylesheet"
    />
    <style>
      body {
        font-family: 'Inter', sans-serif;
        background-color: #f8f7f2;
        color: #1a472a;
      }
      h1,
      h2,
      h3,
      h4,
      h5,
      h6 {
        font-family: 'Nunito', sans-serif;
      }
      .card {
        background-color: #ffffff;
        @apply rounded-xl shadow-lg ring-1 ring-black/5;
      }
      .status-dot {
        @apply w-2.5 h-2.5 rounded-full transition-colors;
      }
      .tooltip {
        @apply absolute invisible z-20 w-max max-w-xs bg-gray-800 text-white text-xs rounded-lg px-3 py-2 -mt-10 transition-opacity duration-300 shadow-xl;
      }
      .has-tooltip:hover .tooltip {
        @apply visible opacity-100;
      }
      input[type='number']::-webkit-inner-spin-button,
      input[type='number']::-webkit-outer-spin-button {
        -webkit-appearance: none;
        margin: 0;
      }
      input[type='number'] {
        -moz-appearance: textfield;
      }
      .custom-scrollbar::-webkit-scrollbar {
        height: 8px;
      }
      .custom-scrollbar::-webkit-scrollbar-track {
        background-color: #f1f5f9;
        border-radius: 10px;
      }
      .custom-scrollbar::-webkit-scrollbar-thumb {
        background-color: #a8c899;
        border-radius: 10px;
      }
      .sticky-header thead {
        position: sticky;
        top: 0;
        z-index: 10;
      }
            /* Animated predicted progress bar */
      .progress-outer { width: 100%; background: #e5e7eb; height: 10px; border-radius: 9999px; overflow: hidden; }
      .progress-inner { height: 10px; background: #16a34a; border-radius: 9999px; width: 0%; transition: width 600ms cubic-bezier(0.22, 1, 0.36, 1); }

      /* Slider styling aligned with theme greens (no dark border, gray track, subtle hover) */
      input[type='range'] { accent-color: #A8C899; }
      .ratio-slider {
        -webkit-appearance: none; appearance: none;
        height: 8px; width: 10rem;
        background: #e5e7eb; /* JS sets a gradient fill for value */
        border-radius: 9999px; outline: none; transition: filter 120ms ease;
      }
      .ratio-slider:hover { filter: brightness(1.02); }
      .ratio-slider:focus { box-shadow: 0 0 0 3px rgba(168,200,153,0.35); }
      .ratio-slider::-webkit-slider-thumb {
        -webkit-appearance: none; appearance: none;
        height: 18px; width: 18px; border-radius: 9999px;
        background-color: #ffffff; border: 2px solid #A8C899; cursor: pointer;
        transition: transform 120ms ease, box-shadow 120ms ease;
      }
      .ratio-slider:hover::-webkit-slider-thumb { transform: scale(1.06); box-shadow: 0 1px 6px rgba(26,71,42,0.18); }
      .ratio-slider:active::-webkit-slider-thumb { transform: scale(1.08); }
      .ratio-slider::-moz-range-thumb {
        height: 18px; width: 18px; border-radius: 9999px;
        background-color: #ffffff; border: 2px solid #A8C899; cursor: pointer;
        transition: transform 120ms ease, box-shadow 120ms ease;
      }
      .ratio-slider:hover::-moz-range-thumb { transform: scale(1.06); box-shadow: 0 1px 6px rgba(26,71,42,0.18); }
      .ratio-slider:active::-moz-range-thumb { transform: scale(1.08); }
      .ratio-slider::-moz-range-track { height: 8px; background-color: #e5e7eb; border-radius: 9999px; }
      /* Ensure focused inputs/selects/textareas match theme green (override orange outlines on some browsers) */
      input:focus, select:focus, textarea:focus {
        outline: none !important;
        box-shadow: 0 0 0 3px rgba(168,200,153,0.35) !important;
        border-color: #A8C899 !important;
      }
      /* Range input specific (for browsers that show orange outline on focus) */
      input[type='range']:focus { box-shadow: 0 0 0 3px rgba(168,200,153,0.35) !important; }

      /* Subtle entrance + feedback animations */
      .row-enter { animation: fadeSlideIn 280ms ease-out both; }
      @keyframes fadeSlideIn {
        from { opacity: 0; transform: translateY(6px); }
        to   { opacity: 1; transform: translateY(0); }
      }
      .pulse-highlight { animation: pulseGlow 900ms ease-out 1; }
      @keyframes pulseGlow {
        0% { box-shadow: 0 0 0 0 rgba(168,200,153,0.0); }
        35% { box-shadow: 0 0 0 6px rgba(168,200,153,0.28); }
        100% { box-shadow: 0 0 0 0 rgba(168,200,153,0.0); }
      }

      /* Animated predicted progress bar */
      .progress-outer { width: 100%; background: #e5e7eb; height: 10px; border-radius: 9999px; overflow: hidden; }
      .progress-inner { height: 10px; background: #16a34a; border-radius: 9999px; width: 0%; transition: width 600ms cubic-bezier(0.22, 1, 0.36, 1); }

      /* Button micro-interactions */
      .get-prediction-btn, .copy-row-btn, .delete-row-btn, #add-row-btn, #find-optimal-mix-btn, #export-csv-btn {
        transition: transform 120ms ease, box-shadow 160ms ease;
      }
      .get-prediction-btn:hover, .copy-row-btn:hover, .delete-row-btn:hover, #add-row-btn:hover, #find-optimal-mix-btn:hover, #export-csv-btn:hover {
        transform: translateY(-1px);
        box-shadow: 0 6px 12px rgba(26,71,42,0.08);
      }
      .get-prediction-btn:active, .copy-row-btn:active, .delete-row-btn:active, #add-row-btn:active, #find-optimal-mix-btn:active, #export-csv-btn:active {
        transform: translateY(0);
      }
    </style>
  </head>
  <body class="text-gray-800">
    <div class="container mx-auto p-4 sm:p-6 lg:p-8 max-w-7xl">
      <header class="flex justify-between items-center mb-10">
        <div class="flex items-center space-x-4">
          <img src="./assets/icon.png" alt="Logo" class="w-200 h-12" />
          <div>
            <h1 class="text-3xl font-extrabold text-[#1A472A]">
              Biofilm Prediction Tool
            </h1>
            <p class="text-gray-500 text-sm">
              Optimize and predict biofilm removal using enzyme mixtures.
            </p>
          </div>
        </div>
        <div class="flex items-center space-x-3">
          <div
            id="status-dot"
            class="status-dot bg-yellow-400 animate-pulse"
          ></div>
          <span id="status-text" class="text-sm text-yellow-600 font-medium"
            >Connecting to API...</span
          >
          <!-- header copy button removed; per-row copy buttons used instead -->
        </div>
      </header>

      <div class="card p-5 mb-8">
        <h2 class="text-xl font-bold mb-2">Model Overview</h2>
        <p class="text-sm text-gray-700">
          Wet‑lab screening of enzyme cocktails is expensive and slow. We trained an XGBoost model on past experiments to predict biofilm degradation (%) from the ratio of Dispersin B (DspB), DNase I, and Proteinase K (ProK). Hence the model can:
        </p>
        <ul class="list-disc ml-6 mt-2 text-sm text-gray-700">
          <li>Suggests a ratio most likely to degrade biofilm.</li>
          <li>Predicts percentage of degradation, based on user input.</li>
        </ul>
      </div>

      <div class="grid grid-cols-1 lg:grid-cols-3 gap-8">
        <div class="lg:col-span-1 flex flex-col gap-8">
          <div class="card p-6">
            <h2 class="text-xl font-bold mb-4">Standard Assay Conditions</h2>
            <div class="space-y-4">
              <div class="grid grid-cols-2 gap-4">
                <div>
                  <label
                    for="fixed-ph"
                    class="block text-sm font-medium text-gray-700"
                    >pH</label
                  ><input
                    type="number"
                    id="fixed-ph"
                    value="7.4"
                    step="0.1"
                    class="mt-1 w-full bg-gray-100 border-gray-300 rounded-lg shadow-sm p-2 text-sm"
                  />
                </div>
                <div>
                  <label
                    for="fixed-temp"
                    class="block text-sm font-medium text-gray-700"
                    >Temp (°C)</label
                  ><input
                    type="number"
                    id="fixed-temp"
                    value="37"
                    class="mt-1 w-full bg-gray-100 border-gray-300 rounded-lg shadow-sm p-2 text-sm"
                  />
                </div>
              </div>
              <div class="grid grid-cols-2 gap-4">
                <div>
                  <label
                    for="total-volume"
                    class="block text-sm font-medium text-gray-700"
                    >Total Volume (µL)</label
                  ><input
                    type="number"
                    id="total-volume"
                    value="100"
                    class="mt-1 w-full bg-gray-100 border-gray-300 rounded-lg shadow-sm p-2 text-sm"
                  />
                </div>
                <div>
                  <label
                    for="biofilm-age"
                    class="block text-sm font-medium text-gray-700"
                    >Biofilm Age (h)</label
                  ><input
                    type="number"
                    id="biofilm-age"
                    value="24"
                    class="mt-1 w-full bg-gray-100 border-gray-300 rounded-lg shadow-sm p-2 text-sm"
                  />
                </div>
              </div>
              <!-- Estimated concentration per-row will be computed from server-provided optimal total concentration when available, otherwise a standard fallback is used -->
              <div>
                <label
                  for="control-od"
                  class="block text-sm font-medium text-gray-700"
                  >Control OD600</label
                ><input
                  type="number"
                  id="control-od"
                  step="0.01"
                  value="0.80"
                  class="mt-1 w-full bg-gray-100 border-gray-300 rounded-lg shadow-sm p-2 text-sm"
                />
              </div>
            </div>
            <div class="mt-6 border-t pt-4 space-y-3">
              <button
                id="find-optimal-mix-btn"
                class="w-full px-5 py-2.5 rounded-lg font-semibold text-sm bg-[#A8C899] text-[#1A472A] hover:bg-[#99bb8a] shadow-md transition-colors shadow-md"
              >
                Find Optimal Mix
              </button>
              

            </div>
          </div>
          <div class="card p-6">
            <h2 class="text-xl font-bold mb-4">Results Summary</h2>
            <div id="summary-metrics" class="space-y-3 text-sm">
              <div class="flex justify-between items-center">
                <span class="text-gray-600">Experiments Run:</span
                ><span id="summary-count" class="font-bold text-lg">0</span>
              </div>
              <div class="flex justify-between items-center">
                <span class="text-gray-600">Best Prediction:</span
                ><span
                  id="summary-best"
                  class="font-bold text-lg text-green-600"
                  >-</span
                >
              </div>
              <div class="flex justify-between items-center">
                <span class="text-gray-600">Mean Prediction:</span
                ><span id="summary-mean" class="font-bold text-lg">-</span>
              </div>
            </div>
          </div>
          <div class="card p-6">
            <h2 class="text-xl font-bold mb-4">Prediction Analysis</h2>
            <div id="analysis-metrics" class="space-y-3 text-sm">
              <div class="flex justify-between items-center">
                <span class="text-gray-600">Model Accuracy (MAE):</span
                ><span id="analysis-mae" class="font-bold text-lg">-</span>
              </div>
              <p class="text-xs text-gray-500 italic mt-2">
                Mean Absolute Error between actual and predicted values.
              </p>
            </div>
          </div>
          
        </div>

        <div class="lg:col-span-2">
          <div class="card overflow-hidden">
            <div class="overflow-x-auto custom-scrollbar sticky-header">
              <table class="w-full" id="experiment-table">
                <thead class="bg-gray-50">
                  <tr class="text-left text-sm font-semibold text-gray-600">
                    <th class="p-4">#</th>
                    <!-- Row column removed -->
                    <th class="p-4 min-w-[320px]">Volume Ratios</th>
                    <th class="p-4">Strategy</th>
                    <th class="p-4">Delays (h)</th>
                    <th class="p-4">Time (h)</th>
                    <th class="p-4">Final OD</th>
                    <th class="p-4">Actual</th>
                    <th class="p-4 min-w-[250px]">Predicted</th>
                    <th class="p-4">Action</th>
                  </tr>
                </thead>
                <tbody id="table-body" class="divide-y divide-gray-100"></tbody>
              </table>
            </div>
          </div>
          <div class="mt-6 flex justify-center gap-4">
            <button
              id="add-row-btn"
              class="px-5 py-2.5 rounded-lg font-semibold text-sm bg-[#A8C899] text-[#1A472A] hover:bg-[#99bb8a] shadow-md"
            >
              Add Experiment
            </button>
            <button
              id="export-csv-btn"
              class="px-5 py-2.5 rounded-lg font-semibold text-sm bg-white text-gray-700 border border-gray-300 hover:bg-gray-100 shadow-md"
            >
              Export CSV
            </button>
          </div>
        </div>
      </div>

      <div class="grid grid-cols-1 lg:grid-cols-2 gap-8 mt-8">
        <div class="card p-6">
          <h2 class="text-xl font-bold mb-4">Top Feature Importances</h2>
          <div id="plot-feature-importance" class="min-h-[400px]"></div>
        </div>
        <div class="card p-6">
          <h2 class="text-xl font-bold mb-4">
            Enzyme Ratio vs. Predicted Removal
          </h2>
          <div id="ternary-plot" class="min-h-[400px]"></div>
        </div>
        <div class="card p-6">
          <h2 class="text-xl font-bold mb-4">Enzyme Ratio vs. Actual Removal (from OD600)</h2>
          <div id="ternary-actual-plot" class="min-h-[400px]"></div>
        </div>
      </div>
    </div>

    <script>
      document.addEventListener('DOMContentLoaded', () => {
        const API_URL = (function(){
          const host = window.location.hostname;
          if (host === '54.237.111.117') return 'http://54.237.111.117:8000';
          return 'http://127.0.0.1:8000';
        })();
        const tableBody = document.getElementById('table-body');
        const addRowBtn = document.getElementById('add-row-btn');
        const findOptimalMixBtn = document.getElementById('find-optimal-mix-btn');
        
        const exportCsvBtn = document.getElementById('export-csv-btn');
        let experimentCount = 0;
        const inputBaseClasses =
          'w-full bg-gray-100 border-gray-300 rounded-lg shadow-sm p-2 text-sm';

        let SCHEMA_STATS = null;

        async function fetchSchemaStats() {
          try {
            const r = await fetch(`${API_URL}/training-schema-stats`);
            if (!r.ok) return;
            SCHEMA_STATS = await r.json();
            applySchemaConstraints();
          } catch (e) {
            // silently ignore if not available
          }
        }

        function rowsToCsv() {
          const header = [
            'DspB_ratio','DNase_I_ratio','ProK_ratio',
            'Reaction_Time','DNase_Addition_Time','ProK_Addition_Time','Addition_Strategy',
            'pH','Temperature','Total_Volume','biofilm_age_hours',
            'Predicted','PI_low','PI_high'
          ];
          const pH = parseFloat(document.getElementById('fixed-ph').value) || '';
          const temp = parseFloat(document.getElementById('fixed-temp').value) || '';
          const totalVol = parseFloat(document.getElementById('total-volume').value) || '';
          const age = parseFloat(document.getElementById('biofilm-age').value) || '';
          const rows = Array.from(tableBody.querySelectorAll('tr')).map((row) => {
            let d = parseFloat(row.querySelector('.ratio-dspb')?.value) || 0;
            let n = parseFloat(row.querySelector('.ratio-dnase')?.value) || 0;
            let p = parseFloat(row.querySelector('.ratio-prok')?.value) || 0;
            const s = d + n + p || 1;
            d = d / s; n = n / s; p = p / s;
            const rt = parseFloat(row.querySelector('.total-time')?.value) || '';
            const tdn = parseFloat(row.querySelector('.dnase-time')?.value) || '';
            const tpk = parseFloat(row.querySelector('.prok-time')?.value) || '';
            const strat = parseInt(row.querySelector('.strategy-select')?.value) || 0;
            const predEl = row.querySelector('[data-prediction]');
            const pred = predEl ? parseFloat(predEl.dataset.prediction) : '';
            let pil = '', pih = '';
            const tip = row.querySelector('.removal-predicted .has-tooltip');
            if (tip && tip.textContent) {
              const m = tip.textContent.match(/\[(.*?)% - (.*?)%\]/);
              if (m) { pil = m[1]; pih = m[2]; }
            }
            return [d, n, p, rt, tdn, tpk, strat, pH, temp, totalVol, age, pred, pil, pih]
              .map((v) => (typeof v === 'number' ? String(v) : String(v)));
          });
          const csv = [header.join(','), ...rows.map(r => r.join(','))].join('\n');
          return csv;
        }

        function downloadCsv(text, filename='experiments.csv') {
          const blob = new Blob([text], { type: 'text/csv;charset=utf-8;' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = filename;
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
        }

        // Backend hard caps derived from PredictionRequest in src/api.py
        const HARD_LIMITS = {
          DspB_ratio: { min: 0 },
          DNase_I_ratio: { min: 0 },
          ProK_ratio: { min: 0 },
          Total_Volume: { min: 10 },
          pH: { min: 6.8, max: 8.2 },
          Temperature: { min: 30, max: 42 },
          Reaction_Time: { min: 1 },
          Addition_Strategy: { min: 0, max: 1 },
          DNase_Addition_Time: { min: 0 },
          ProK_Addition_Time: { min: 0 },
          biofilm_age_hours: { min: 12, max: 96 },
        };

        function applySchemaConstraints() {
          if (!SCHEMA_STATS) return;
          const map = [
            { id: 'fixed-ph', key: 'pH' },
            { id: 'fixed-temp', key: 'Temperature' },
            { id: 'total-volume', key: 'Total_Volume' },
            { id: 'biofilm-age', key: 'biofilm_age_hours' },
          ];
          for (const { id, key } of map) {
            const el = document.getElementById(id);
            const st = SCHEMA_STATS[key];
            if (el && st) {
              const hard = HARD_LIMITS[key] || {};
              const effMin = Math.max(
                typeof st.min === 'number' ? st.min : -Infinity,
                typeof hard.min === 'number' ? hard.min : -Infinity
              );
              const effMax = Math.min(
                typeof st.max === 'number' ? st.max : Infinity,
                typeof hard.max === 'number' ? hard.max : Infinity
              );
              if (isFinite(effMin)) el.min = String(effMin);
              if (isFinite(effMax)) el.max = String(effMax);
              const cur = parseFloat(el.value);
              if (!isNaN(cur)) {
                el.value = String(Math.min(isFinite(effMax) ? effMax : cur, Math.max(isFinite(effMin) ? effMin : cur, cur)));
              }
              // If schema indicates a fixed constant (min == max), force value; also respect hard caps
              if (typeof st.min === 'number' && typeof st.max === 'number' && st.min === st.max) {
                let fixed = st.min;
                if (typeof hard.max === 'number' && fixed > hard.max) fixed = hard.max;
                if (typeof hard.min === 'number' && fixed < hard.min) fixed = hard.min;
                el.value = String(fixed);
                el.disabled = true;
                el.title = 'Fixed by training schema';
              }
            }
          }

          // Apply min/max to per-row inputs for times based on schema stats
          const rt = SCHEMA_STATS['Reaction_Time'];
          const dt = SCHEMA_STATS['DNase_Addition_Time'];
          const pt = SCHEMA_STATS['ProK_Addition_Time'];
          document.querySelectorAll('#table-body tr').forEach((row) => {
            const totalTime = row.querySelector('.total-time');
            const dnaseTime = row.querySelector('.dnase-time');
            const prokTime = row.querySelector('.prok-time');
            if (totalTime && rt) {
              const hard = HARD_LIMITS['Reaction_Time'] || {};
              const effMin = Math.max(typeof rt.min === 'number' ? rt.min : -Infinity, typeof hard.min === 'number' ? hard.min : -Infinity);
              const effMax = Math.min(typeof rt.max === 'number' ? rt.max : Infinity, typeof hard.max === 'number' ? hard.max : Infinity);
              if (isFinite(effMin)) totalTime.min = String(effMin);
              if (isFinite(effMax)) totalTime.max = String(effMax);
              const v = parseFloat(totalTime.value);
              if (!isNaN(v)) totalTime.value = String(Math.min(isFinite(effMax) ? effMax : v, Math.max(isFinite(effMin) ? effMin : v, v)));
              if (typeof rt.min === 'number' && typeof rt.max === 'number' && rt.min === rt.max) {
                let fixed = rt.min;
                if (typeof hard.max === 'number' && fixed > hard.max) fixed = hard.max;
                if (typeof hard.min === 'number' && fixed < hard.min) fixed = hard.min;
                totalTime.value = String(fixed);
                totalTime.disabled = true;
                totalTime.title = 'Fixed by training schema';
              }
            }
            if (dnaseTime && dt) {
              const hard = HARD_LIMITS['DNase_Addition_Time'] || {};
              const effMin = Math.max(typeof dt.min === 'number' ? dt.min : -Infinity, typeof hard.min === 'number' ? hard.min : -Infinity);
              const effMax = Math.min(typeof dt.max === 'number' ? dt.max : Infinity, typeof hard.max === 'number' ? hard.max : Infinity);
              if (isFinite(effMin)) dnaseTime.min = String(effMin);
              if (isFinite(effMax)) dnaseTime.max = String(effMax);
              const v = parseFloat(dnaseTime.value);
              if (!isNaN(v)) dnaseTime.value = String(Math.min(isFinite(effMax) ? effMax : v, Math.max(isFinite(effMin) ? effMin : v, v)));
              if (typeof dt.min === 'number' && typeof dt.max === 'number' && dt.min === dt.max) {
                let fixed = dt.min;
                if (typeof hard.max === 'number' && fixed > hard.max) fixed = hard.max;
                if (typeof hard.min === 'number' && fixed < hard.min) fixed = hard.min;
                dnaseTime.value = String(fixed);
                dnaseTime.disabled = true;
                dnaseTime.title = 'Fixed by training schema';
              }
            }
            if (prokTime && pt) {
              const hard = HARD_LIMITS['ProK_Addition_Time'] || {};
              const effMin = Math.max(typeof pt.min === 'number' ? pt.min : -Infinity, typeof hard.min === 'number' ? hard.min : -Infinity);
              const effMax = Math.min(typeof pt.max === 'number' ? pt.max : Infinity, typeof hard.max === 'number' ? hard.max : Infinity);
              if (isFinite(effMin)) prokTime.min = String(effMin);
              if (isFinite(effMax)) prokTime.max = String(effMax);
              const v = parseFloat(prokTime.value);
              if (!isNaN(v)) prokTime.value = String(Math.min(isFinite(effMax) ? effMax : v, Math.max(isFinite(effMin) ? effMin : v, v)));
              if (typeof pt.min === 'number' && typeof pt.max === 'number' && pt.min === pt.max) {
                let fixed = pt.min;
                if (typeof hard.max === 'number' && fixed > hard.max) fixed = hard.max;
                if (typeof hard.min === 'number' && fixed < hard.min) fixed = hard.min;
                prokTime.value = String(fixed);
                prokTime.disabled = true;
                prokTime.title = 'Fixed by training schema';
              }
            }
          });
        }

        async function checkApiStatus() {
          const statusDot = document.getElementById('status-dot');
          const statusText = document.getElementById('status-text');
          
          try {
            const response = await fetch(`${API_URL}/`);
            if (!response.ok) throw new Error('API not ready');
            const data = await response.json();
            statusDot.className = 'status-dot bg-green-500';
            statusText.textContent = `API Connected (${data.model})`;
            statusText.className = 'text-sm text-green-700 font-medium';
            renderCoreFeatureImportancePlot();
            fetchSchemaStats();
            
          } catch (error) {
            statusDot.className = 'status-dot bg-red-500 animate-pulse';
            statusText.textContent = 'API Offline';
            statusText.className = 'text-sm text-red-600 font-medium';
          }
        }

        const initialData = [
          {
            dspb: 0.34,
            dnase: 0.33,
            prok: 0.33,
            strategy: 0,
            totalTime: 24,
            dnaseTime: 0,
            prokTime: 4,
          },
          {
            dspb: 0.34,
            dnase: 0.33,
            prok: 0.33,
            strategy: 1,
            totalTime: 24,
            dnaseTime: 2,
            prokTime: 6,
          },
        ];

        function normalizeConfigRatios(cfg) {
          let d = Number(cfg.dspb ?? 0);
          let n = Number(cfg.dnase ?? 0);
          let p = Number(cfg.prok ?? 0);
          // If inputs look like 0..1 values, clamp only (don't convert)
          if (d <= 1 && n <= 1 && p <= 1) {
            return { d: Math.max(0, Math.min(1, d)), n: Math.max(0, Math.min(1, n)), p: Math.max(0, Math.min(1, p)) };
          }
          // Otherwise, treat as counts and normalize to proportions
          const s = d + n + p;
          if (!isFinite(s) || s <= 0) return { d: 1/3, n: 1/3, p: 1/3 };
          return { d: d / s, n: n / s, p: p / s };
        }

        function createRow(config) {
          experimentCount++;
          const row = document.createElement('tr');
          row.className = 'hover:bg-gray-50';
          row.dataset.id = experimentCount;
          const norm = normalizeConfigRatios(config || {});
          row.innerHTML = `
            <td class="p-4 text-gray-500 font-medium">${String(
              experimentCount
            ).padStart(2, '0')}</td>
            <!-- row-index cell removed to match header -->
            <td class="p-4"><div class="space-y-2">
                <div class="flex items-center gap-2">
                  <label class="text-xs font-bold text-gray-500 w-24">Dispersin B</label>
                  <input type="range" class="ratio-dspb-slider ratio-slider w-40" min="0" max="1" step="0.01" value="${norm.d}">
                  <input type="number" class="ratio-dspb ${inputBaseClasses} w-20" min="0" max="1" step="0.01" value="${norm.d.toFixed(2)}">
                </div>
                <div class="flex items-center gap-2">
                  <label class="text-xs font-bold text-gray-500 w-24">DNase I</label>
                  <input type="range" class="ratio-dnase-slider ratio-slider w-40" min="0" max="1" step="0.01" value="${norm.n}">
                  <input type="number" class="ratio-dnase ${inputBaseClasses} w-20" min="0" max="1" step="0.01" value="${norm.n.toFixed(2)}">
                </div>
                <div class="flex items-center gap-2">
                  <label class="text-xs font-bold text-gray-500 w-24">Proteinase K</label>
                  <input type="range" class="ratio-prok-slider ratio-slider w-40" min="0" max="1" step="0.01" value="${norm.p}">
                  <input type="number" class="ratio-prok ${inputBaseClasses} w-20" min="0" max="1" step="0.01" value="${norm.p.toFixed(2)}">
                </div>
                <div class="flex items-center justify-between mt-1">
                  <div class="text-xs text-gray-500">Est. vol: <span class="estimated-conc font-medium">-</span></div>
                </div>
            </div></td>
            <td class="p-4"><select class="strategy-select ${inputBaseClasses} w-48"><option value="0" ${
            config.strategy == 0 ? 'selected' : ''
          }>DspB+DNase First</option><option value="1" ${
            config.strategy == 1 ? 'selected' : ''
          }>Fully Sequential</option></select></td>
            <td class="p-4"><div class="space-y-2"><input type="number" title="DNase Add Time" class="dnase-time ${inputBaseClasses} w-24" value="${
            config.dnaseTime
          }" min="0"><input type="number" title="ProK Add Time" class="prok-time ${inputBaseClasses} w-24" value="${
            config.prokTime
          }" min="0"></div></td>
            <td class="p-4"><input type="number" class="total-time ${inputBaseClasses} w-24" value="${
            config.totalTime
          }" min="1"></td>
            <td class="p-4"><input type="number" class="od600 ${inputBaseClasses} w-24" step="0.01" min="0"></td>
            <td class="p-4 font-semibold removal-actual">-</td>
            <td class="p-4 font-medium removal-predicted">-</td>
            <td class="p-4">
              <div class="flex flex-col gap-2">
                <button class="get-prediction-btn px-4 py-2 rounded-lg font-semibold text-xs bg-[#A8C899] text-[#1A472A] hover:bg-[#99bb8a]">Predict</button>
                <div class="flex gap-2">
                  <button class="copy-row-btn px-3 py-1.5 rounded-lg font-semibold text-xs bg-white text-gray-700 border border-gray-300 hover:bg-gray-100">Copy</button>
                  <button class="delete-row-btn px-3 py-1.5 rounded-lg font-semibold text-xs bg-red-50 text-red-700 border border-red-200 hover:bg-red-100">Delete</button>
                </div>
              </div>
            </td>
          `;
          tableBody.appendChild(row);
          attachRowListeners(row);
          updateRowState(row);
        }

        function attachRowListeners(row) {
          row
            .querySelector('.od600')
            .addEventListener('input', () => calculateRemoval(row));
          row
            .querySelector('.get-prediction-btn')
            .addEventListener('click', (e) =>
              getPrediction(row, e.currentTarget)
            );
          // copy current row as a new experiment
          const copyBtn = row.querySelector('.copy-row-btn');
          if (copyBtn) {
            copyBtn.addEventListener('click', () => {
              const cfg = {
                dspb: parseFloat(row.querySelector('.ratio-dspb')?.value) || 0,
                dnase: parseFloat(row.querySelector('.ratio-dnase')?.value) || 0,
                prok: parseFloat(row.querySelector('.ratio-prok')?.value) || 0,
                strategy: parseInt(row.querySelector('.strategy-select')?.value || '0'),
                totalTime: parseFloat(row.querySelector('.total-time')?.value) || 24,
                dnaseTime: parseFloat(row.querySelector('.dnase-time')?.value) || 0,
                prokTime: parseFloat(row.querySelector('.prok-time')?.value) || 0,
              };
              createRow(cfg);
              updateAllVisualizations();
            });
          }
          // delete this row
          const delBtn = row.querySelector('.delete-row-btn');
          if (delBtn) {
            delBtn.addEventListener('click', () => {
              row.remove();
              updateAllVisualizations();
            });
          }
          
          // ratio slider/number synchronization with sum=1 constraint
          const numD = row.querySelector('.ratio-dspb');
          const numN = row.querySelector('.ratio-dnase');
          const numP = row.querySelector('.ratio-prok');
          const sldD = row.querySelector('.ratio-dspb-slider');
          const sldN = row.querySelector('.ratio-dnase-slider');
          const sldP = row.querySelector('.ratio-prok-slider');

          function setSliderFill(sl) {
            if (!sl) return;
            const min = parseFloat(sl.min) || 0;
            const max = parseFloat(sl.max) || 1;
            const val = parseFloat(sl.value) || 0;
            const pct = Math.max(0, Math.min(100, ((val - min) / (max - min)) * 100));
            sl.style.background = `linear-gradient(to right, #A8C899 0%, #A8C899 ${pct}%, #e5e7eb ${pct}%, #e5e7eb 100%)`;
          }

          function getVals() {
            return {
              d: Math.max(0, Math.min(1, parseFloat(numD.value) || 0)),
              n: Math.max(0, Math.min(1, parseFloat(numN.value) || 0)),
              p: Math.max(0, Math.min(1, parseFloat(numP.value) || 0)),
            };
          }
          function setDisplay(d, n, p) {
            d = Math.max(0, Math.min(1, d));
            n = Math.max(0, Math.min(1, n));
            p = Math.max(0, Math.min(1, p));
            numD.value = d.toFixed(2);
            numN.value = n.toFixed(2);
            numP.value = p.toFixed(2);
            sldD.value = String(d);
            sldN.value = String(n);
            sldP.value = String(p);
            setSliderFill(sldD); setSliderFill(sldN); setSliderFill(sldP);
            updateAllVisualizations();
            updateRowEstimatedConc(row);
          }

          // Track last two edited keys to decide which values remain fixed
          const editHistory = [];
          function pushHistory(k) {
            const i = editHistory.indexOf(k);
            if (i !== -1) editHistory.splice(i, 1);
            editHistory.push(k);
            if (editHistory.length > 2) editHistory.shift();
          }

          function enforceAfterEdit(active, val) {
            val = Math.max(0, Math.min(1, val));
            pushHistory(active);
            let { d, n, p } = getVals();
            const keys = ['d','n','p'];
            const fixed = editHistory.slice();
            if (fixed.length < 2) {
              // Adjust other two proportionally to fill remainder
              if (active === 'd') {
                const rem = Math.max(0, 1 - val);
                const sum = n + p;
                const nn = sum > 0 ? (n / sum) * rem : rem * 0.5;
                const pp = rem - nn;
                setDisplay(val, nn, pp);
              } else if (active === 'n') {
                const rem = Math.max(0, 1 - val);
                const sum = d + p;
                const dd = sum > 0 ? (d / sum) * rem : rem * 0.5;
                const pp = rem - dd;
                setDisplay(dd, val, pp);
              } else {
                const rem = Math.max(0, 1 - val);
                const sum = d + n;
                const dd = sum > 0 ? (d / sum) * rem : rem * 0.5;
                const nn = rem - dd;
                setDisplay(dd, nn, val);
              }
              return;
            }
            // Two locked
            const vals = { d, n, p };
            const varKey = keys.find((k) => !fixed.includes(k));
            const otherFixed = fixed.find((k) => k !== active) || fixed[0];

            if (!fixed.includes(active)) {
              // Case A: last two edited are the other two (keep them fixed), set active = 1 - sum(fixed)
              const fixedSum = (vals[fixed[0]] || 0) + (vals[fixed[1]] || 0);
              const newActive = Math.max(0, 1 - fixedSum);
              vals[active] = newActive;
              setDisplay(vals.d, vals.n, vals.p);
              return;
            }

            // Case B: active is one of the fixed pair: clamp active, adjust only the remaining var
            const maxActive = 1 - (vals[otherFixed] || 0);
            const newActive = Math.max(0, Math.min(val, maxActive));
            vals[active] = newActive;
            const fixedSum = newActive + (vals[otherFixed] || 0);
            const newVar = Math.max(0, 1 - fixedSum);
            vals[varKey] = newVar;
            setDisplay(vals.d, vals.n, vals.p);
          }

          // Slider input events
          sldD.addEventListener('input', () => enforceAfterEdit('d', parseFloat(sldD.value) || 0));
          sldN.addEventListener('input', () => enforceAfterEdit('n', parseFloat(sldN.value) || 0));
          sldP.addEventListener('input', () => enforceAfterEdit('p', parseFloat(sldP.value) || 0));
          // Number inputs: live update only own slider + fill; commit on change/blur/Enter
          function clamp01(x){ x=parseFloat(x); return isFinite(x)? Math.max(0, Math.min(1, x)) : 0; }
          numD.addEventListener('input', () => { const v=clamp01(numD.value); sldD.value=String(v); setSliderFill(sldD); });
          numN.addEventListener('input', () => { const v=clamp01(numN.value); sldN.value=String(v); setSliderFill(sldN); });
          numP.addEventListener('input', () => { const v=clamp01(numP.value); sldP.value=String(v); setSliderFill(sldP); });
          ['change','blur'].forEach(evt=>{
            numD.addEventListener(evt, () => enforceAfterEdit('d', clamp01(numD.value)));
            numN.addEventListener(evt, () => enforceAfterEdit('n', clamp01(numN.value)));
            numP.addEventListener(evt, () => enforceAfterEdit('p', clamp01(numP.value)));
          });
          [numD,numN,numP].forEach(inp=>inp.addEventListener('keydown', (e)=>{ if(e.key==='Enter'){ e.preventDefault(); e.currentTarget.blur(); }}));

          // Initialize slider fill visuals for current values
          setSliderFill(sldD); setSliderFill(sldN); setSliderFill(sldP);
          // clamp time inputs to schema on change
          const timeInputs = row.querySelectorAll('.total-time, .dnase-time, .prok-time');
          timeInputs.forEach((inp) => {
            inp.addEventListener('change', () => {
              if (!SCHEMA_STATS) return;
              const key = inp.classList.contains('total-time')
                ? 'Reaction_Time'
                : inp.classList.contains('dnase-time')
                ? 'DNase_Addition_Time'
                : 'ProK_Addition_Time';
              const st = SCHEMA_STATS[key];
              if (!st) return;
              let v = parseFloat(inp.value);
              if (!isFinite(v)) return;
              if (typeof st.min === 'number' && v < st.min) v = st.min;
              if (typeof st.max === 'number' && v > st.max) v = st.max;
              inp.value = String(v);
              updateAllVisualizations();
            });
          });
          row
            .querySelector('.strategy-select')
            .addEventListener('change', () => updateRowState(row));

          // per-row copy button
          const perRowCopy = row.querySelector('.per-row-copy-btn');
          if (perRowCopy) {
            perRowCopy.addEventListener('click', async () => {
              const dRaw = parseFloat(row.querySelector('.ratio-dspb')?.value) || 0;
              const nRaw = parseFloat(row.querySelector('.ratio-dnase')?.value) || 0;
              const pRaw = parseFloat(row.querySelector('.ratio-prok')?.value) || 0;
              const s = dRaw + nRaw + pRaw || 1;
              const dPct = (dRaw / s) * 100;
              const nPct = (nRaw / s) * 100;
              const pPct = (pRaw / s) * 100;
              const rt = parseFloat(row.querySelector('.total-time')?.value) || 24;
              const predEl = row.querySelector('[data-prediction]');
              const pred = predEl ? parseFloat(predEl.dataset.prediction) : NaN;
              // Attempt to read PI from tooltip text
              const tip = row.querySelector('.removal-predicted .has-tooltip');
              let pil = '', pih = '';
              if (tip && tip.textContent) {
                const m = tip.textContent.match(/\[(.*?)% - (.*?)%\]/);
                if (m) { pil = m[1]; pih = m[2]; }
              }
              const txt = `DspB=${dPct.toFixed(0)}%, DNase=${nPct.toFixed(0)}%, ProK=${pPct.toFixed(0)}% | Time=${rt}h` +
                          (isFinite(pred) ? ` | Pred=${pred.toFixed(1)}%${(pil&&pih)?` [${pil}% - ${pih}%]`:''}` : '');
              try {
                await copyToClipboard(txt);
                const old = perRowCopy.textContent;
                perRowCopy.textContent = 'Copied';
                setTimeout(() => (perRowCopy.textContent = old), 1800);
              } catch (e) {
                alert('Copy failed: ' + (e && e.message ? e.message : e));
              }
            });
          }

          // initialize estimated conc for this row
          updateRowEstimatedConc(row);
        }

        function computeEstimatedConcForRow(row) {
          // prefer server-provided total stock concentration from lastOptimalMix, otherwise use a sensible default
          const stock = (window.lastOptimalMix && window.lastOptimalMix.total_stock_concentration_mg_ml) ? parseFloat(window.lastOptimalMix.total_stock_concentration_mg_ml) : 1.0;
          const dspb = parseFloat(row.querySelector('.ratio-dspb')?.value) || 0;
          const dnase = parseFloat(row.querySelector('.ratio-dnase')?.value) || 0;
          const prok = parseFloat(row.querySelector('.ratio-prok')?.value) || 0;
          const total = dspb + dnase + prok;
          if (total === 0 || stock === 0) return null;
          // compute fraction each enzyme contributes (based on integer 'counts' proportions)
          const fracD = dspb / total;
          const fracN = dnase / total;
          const fracP = prok / total;
          // per-enzyme concentration (mg/mL) assuming stock concentration is total enzyme stock
          const dspbConc = stock * fracD;
          const dnaseConc = stock * fracN;
          const prokConc = stock * fracP;
          return {
            totalStockConc: stock,
            dspbConc,
            dnaseConc,
            prokConc,
          };
        }

        function updateRowEstimatedConc(row) {
          const el = row.querySelector('.estimated-conc');
          const info = computeEstimatedConcForRow(row);
          if (!el) return;
          if (info === null) {
        el.textContent = '-'; 
        el.removeAttribute('title');
            return;
          }
          // Compute per-enzyme stock volumes (µL) required to achieve per-enzyme concentrations
          // Prefer explicit stock concentration input (#stock-conc), otherwise fall back to info.totalStockConc or 1.0 mg/mL
          const stockInput = parseFloat(document.getElementById('stock-conc')?.value);
          const stock = (isFinite(stockInput) && stockInput > 0) ? stockInput : (isFinite(info.totalStockConc) ? info.totalStockConc : 1.0);

          const totalVolUL = parseFloat(document.getElementById('total-volume')?.value) || 100; // µL final reaction volume
          const totalVolML = totalVolUL / 1000.0; // mL

          // mass (mg) needed per enzyme = conc(mg/mL) * totalVolML
          const dspbMassMg = info.dspbConc * totalVolML;
          const dnaseMassMg = info.dnaseConc * totalVolML;
          const prokMassMg = info.prokConc * totalVolML;

          // stock volume (µL) = (mass_mg / stock_mg_per_mL) * 1000
          const dspbVolUL = stock > 0 ? (dspbMassMg / stock) * 1000.0 : 0;
          const dnaseVolUL = stock > 0 ? (dnaseMassMg / stock) * 1000.0 : 0;
          const prokVolUL = stock > 0 ? (prokMassMg / stock) * 1000.0 : 0;

          const totalStockVolUL = dspbVolUL + dnaseVolUL + prokVolUL;

          el.textContent = `Est. vol — DspB: ${dspbVolUL.toFixed(0)} µL · DNase: ${dnaseVolUL.toFixed(0)} µL · ProK: ${prokVolUL.toFixed(0)} µL · total ${totalStockVolUL.toFixed(0)} µL`;
          el.title = `Per-enzyme conc (mg/mL): DspB ${info.dspbConc.toFixed(2)} • DNase ${info.dnaseConc.toFixed(2)} • ProK ${info.prokConc.toFixed(2)} | Final vol ${totalVolUL} µL | Stock ${stock} mg/mL`;
        }

  // update estimated conc for all rows when lastOptimalMix changes (handled where lastOptimalMix is set)

        // Safe clipboard copy with fallback for older browsers or insecure contexts
        async function copyToClipboard(text) {
          if (navigator.clipboard && typeof navigator.clipboard.writeText === 'function') {
            return navigator.clipboard.writeText(text);
          }
          // fallback: textarea+execCommand
          const ta = document.createElement('textarea');
          ta.value = text;
          ta.style.position = 'fixed';
          ta.style.left = '-9999px';
          document.body.appendChild(ta);
          ta.select();
          try {
            document.execCommand('copy');
          } finally {
            document.body.removeChild(ta);
          }
        }

        // Convert proportional floats (sum may be 1) into integer counts summing to `total`.
        function proportionsToIntegers(props, total = 100) {
          const keys = Object.keys(props);
          const raw = keys.map((k) => Math.max(0, props[k] || 0));
          const sum = raw.reduce((a, b) => a + b, 0);
          const ints = {};
          if (sum === 0) {
            // equal distribution
            const base = Math.floor(total / keys.length);
            keys.forEach((k) => (ints[k] = base));
            let rem = total - base * keys.length;
            let i = 0;
            while (rem > 0) {
              ints[keys[i % keys.length]]++;
              i++;
              rem--;
            }
            return ints;
          }
          const scaled = raw.map((v) => (v / sum) * total);
          keys.forEach((k, i) => (ints[k] = Math.round(scaled[i])));
          let currentSum = Object.values(ints).reduce((a, b) => a + b, 0);
          // adjust rounding differences
          while (currentSum !== total) {
            if (currentSum < total) {
              // add to the largest fractional remainder
              const remainders = keys
                .map((k, i) => ({ k, rem: scaled[i] - Math.floor(scaled[i]) }))
                .sort((a, b) => b.rem - a.rem);
              ints[remainders[0].k]++;
            } else {
              // remove 1 from the largest integer value (>0)
              const sorted = keys
                .map((k) => ({ k, val: ints[k] }))
                .filter((x) => x.val > 0)
                .sort((a, b) => b.val - a.val);
              ints[sorted[0].k]--;
            }
            currentSum = Object.values(ints).reduce((a, b) => a + b, 0);
          }
          return ints;
        }

        function updateRowState(row) {
          const strategy = row.querySelector('.strategy-select').value;
          const dnaseTimeInput = row.querySelector('.dnase-time');
          if (strategy === '0') {
            dnaseTimeInput.value = 0;
            dnaseTimeInput.disabled = true;
          } else {
            dnaseTimeInput.disabled = false;
          }
        }

        function calculateRemoval(row) {
          const controlOD = parseFloat(
            document.getElementById('control-od').value
          );
          const finalOD = parseFloat(row.querySelector('.od600').value);
          const removalCell = row.querySelector('.removal-actual');
          if (!isNaN(controlOD) && !isNaN(finalOD) && controlOD > 0) {
            const removal = Math.max(
              0,
              ((controlOD - finalOD) / controlOD) * 100
            );
            removalCell.textContent = `${removal.toFixed(1)}%`;
            removalCell.dataset.actual = removal;
          } else {
            removalCell.textContent = '-';
            delete removalCell.dataset.actual;
          }
          updateAllVisualizations();
        }

        function validateAgainstSchemaStats(payload) {
          if (!SCHEMA_STATS) return { ok: true };
          const violations = [];
          const RATIO_KEYS = new Set(['DspB_ratio', 'DNase_I_ratio', 'ProK_ratio']);
          for (const [k, v] of Object.entries(payload)) {
            const st = SCHEMA_STATS[k];
            if (!st || typeof v !== 'number' || !isFinite(v)) continue;
            // Skip validation for ratio fields if schema reports 0..0 (indicates unconstrained or engineered away)
            if (RATIO_KEYS.has(k) && st.min === 0 && st.max === 0) continue;
            // Apply backend hard caps in addition to schema
            const hard = HARD_LIMITS[k] || {};
            const effMin = Math.max(
              typeof st.min === 'number' ? st.min : -Infinity,
              typeof hard.min === 'number' ? hard.min : -Infinity
            );
            const effMax = Math.min(
              typeof st.max === 'number' ? st.max : Infinity,
              typeof hard.max === 'number' ? hard.max : Infinity
            );
            // If schema is a fixed constant, auto-clamp instead of erroring
            if (typeof st.min === 'number' && typeof st.max === 'number' && st.min === st.max) {
              // treat as informational in UI; don't block if differs
              continue;
            }
            if (isFinite(effMin) && v < effMin) violations.push(`${k} < min (${v} < ${effMin})`);
            if (isFinite(effMax) && v > effMax) violations.push(`${k} > max (${v} > ${effMax})`);
          }
          if (violations.length) return { ok: false, message: `Out of range: ${violations.join(', ')}` };
          return { ok: true };
        }

        async function getPrediction(row, button) {
          button.disabled = true;
          button.textContent = '...';
          const predictionCell = row.querySelector('.removal-predicted');
          predictionCell.innerHTML =
            '<span class="animate-pulse text-gray-400">Calculating...</span>';
          const payload = {
            DspB_ratio: parseFloat(row.querySelector('.ratio-dspb').value),
            DNase_I_ratio: parseFloat(row.querySelector('.ratio-dnase').value),
            ProK_ratio: parseFloat(row.querySelector('.ratio-prok').value),
            Addition_Strategy: parseInt(
              row.querySelector('.strategy-select').value
            ),
            pH: parseFloat(document.getElementById('fixed-ph').value),
            Temperature: parseFloat(
              document.getElementById('fixed-temp').value
            ),
            Total_Volume: parseFloat(
              document.getElementById('total-volume').value
            ),
            biofilm_age_hours: parseFloat(
              document.getElementById('biofilm-age').value
            ),
            Reaction_Time: parseFloat(row.querySelector('.total-time').value),
            DNase_Addition_Time: parseFloat(
              row.querySelector('.dnase-time').value
            ),
            ProK_Addition_Time: parseFloat(
              row.querySelector('.prok-time').value
            ),
          };
          // Normalize integer counts to proportions before validation/sending
          {
            const s = payload.DspB_ratio + payload.DNase_I_ratio + payload.ProK_ratio;
            if (isFinite(s) && s > 0) {
              payload.DspB_ratio = payload.DspB_ratio / s;
              payload.DNase_I_ratio = payload.DNase_I_ratio / s;
              payload.ProK_ratio = payload.ProK_ratio / s;
            }
          }
          // Validate against schema stats prior to sending
          const vr = validateAgainstSchemaStats(payload);
          if (!vr.ok) {
            predictionCell.innerHTML = `<span class="text-red-500 has-tooltip relative">Invalid<div class="tooltip w-64">${vr.message}</div></span>`;
            button.disabled = false;
            button.textContent = 'Predict';
            return;
          }
          try {
            const response = await fetch(`${API_URL}/predict`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(payload),
            });
            const result = await response.json();
            if (!response.ok) {
              throw new Error(
                (result.detail && result.detail[0]?.msg) ||
                  result.detail ||
                  'Prediction failed.'
              );
            }
            predictionCell.innerHTML = `
              <div class="flex items-center gap-3">
                  <span class="font-bold text-lg text-gray-800" data-prediction="${
                    result.mean_prediction
                  }">${result.mean_prediction.toFixed(1)}%</span>
       <div class="progress-outer"><div class="progress-inner" style="width: 0%"></div></div>

              </div>
              <div class="text-xs text-gray-500 mt-1 has-tooltip relative">
                  95% PI: [${result.prediction_interval_low.toFixed(1)}% - ${result.prediction_interval_high.toFixed(1)}%] &middot; epistemic ${result.epistemic_uncertainty.toFixed(1)}% aleatoric ${result.aleatoric_uncertainty.toFixed(1)}%
                  <div class="tooltip">Kernel: ${result.kernel_contribution.toFixed(1)} | ML: ${result.residual_contribution.toFixed(1)}%</div>
              </div>`;
const bar = predictionCell.querySelector('.progress-inner');
            if (bar) {
              requestAnimationFrame(() => {
                bar.style.width = `${result.mean_prediction}%`;
              });
            }
            // Lock this row's ratio controls so it can't be changed after prediction
            try {
              row.dataset.locked = '1';
              const lockInputs = [
                row.querySelector('.ratio-dspb'),
                row.querySelector('.ratio-dnase'),
                row.querySelector('.ratio-prok'),
                row.querySelector('.ratio-dspb-slider'),
                row.querySelector('.ratio-dnase-slider'),
                row.querySelector('.ratio-prok-slider'),
              ].filter(Boolean);
              lockInputs.forEach((el) => { el.disabled = true; el.title = 'Locked after prediction'; });
              // Mark the button as locked
              if (button) {
                button.disabled = true;
                button.textContent = 'Locked';
                button.classList.add('opacity-60','cursor-not-allowed');
                button.title = 'This row is locked after prediction';
              }
            } catch (_) { /* no-op */ }
          } catch (error) {
            predictionCell.innerHTML = `<span class="text-red-500 has-tooltip relative">Error<div class="tooltip w-48">${error.message}</div></span>`;
            button.disabled = false;
            button.textContent = 'Predict';
          } finally {
            updateAllVisualizations();
          }
        }

        async function findOptimalMix() {
          findOptimalMixBtn.disabled = true;
          findOptimalMixBtn.textContent = 'Optimizing...';

          const firstRow = tableBody.querySelector('tr');
          if (!firstRow) {
            alert(
              'Please add at least one experiment row to define time and strategy.'
            );
            findOptimalMixBtn.disabled = false;
            findOptimalMixBtn.textContent = 'Find Optimal Mix';
            return;
          }

          // Gather prior experiments with actual results to guide the optimization
          const prior_experiments = Array.from(tableBody.querySelectorAll('tr'))
            .map((row) => {
              // read removal actual from the dedicated cell; allow zero values
              const actual = row.querySelector('.removal-actual')?.dataset.actual;
              if (actual === undefined || actual === null || actual === '') return null;

              return {
                inputs: {
                  DspB_ratio: parseFloat(
                    row.querySelector('.ratio-dspb').value
                  ),
                  DNase_I_ratio: parseFloat(
                    row.querySelector('.ratio-dnase').value
                  ),
                  ProK_ratio: parseFloat(
                    row.querySelector('.ratio-prok').value
                  ),
                },
                output: parseFloat(actual),
              };
            })
            .filter(Boolean);

          const payload = {
            fixed_conditions: {
              pH: parseFloat(document.getElementById('fixed-ph').value),
              Temperature: parseFloat(
                document.getElementById('fixed-temp').value
              ),
              Total_Volume: parseFloat(
                document.getElementById('total-volume').value
              ),
              biofilm_age_hours: parseFloat(
                document.getElementById('biofilm-age').value
              ),
              Reaction_Time: parseFloat(
                firstRow.querySelector('.total-time').value
              ),
              Addition_Strategy: parseInt(
                firstRow.querySelector('.strategy-select').value
              ),
              DNase_Addition_Time: parseFloat(
                firstRow.querySelector('.dnase-time').value
              ),
              ProK_Addition_Time: parseFloat(
                firstRow.querySelector('.prok-time').value
              ),
            },
            prior_experiments: prior_experiments,
          };

          try {
            // POST the fixed conditions + prior experiments to the server's /optimal-mix endpoint
            const response = await fetch(`${API_URL}/optimal-mix`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(payload),
            });
            const result = await response.json();
            if (!response.ok) {
              throw new Error(result.detail || 'Optimization failed.');
            }

            // Server returns enriched optimal mix JSON including integer_counts [dspb, dnase, prok] and ratios [dspb, dnase, prok]
            const integerCounts = Array.isArray(result.integer_counts) ? result.integer_counts : null;
            const ratiosArr = Array.isArray(result.ratios) ? result.ratios : null;
            const intsObj = integerCounts
              ? { DspB: integerCounts[0] || 0, DNase: integerCounts[1] || 0, ProK: integerCounts[2] || 0 }
              : (ratiosArr
                  ? proportionsToIntegers({ DspB: ratiosArr[0] || 0, DNase: ratiosArr[1] || 0, ProK: ratiosArr[2] || 0 }, 100)
                  : { DspB: 0.33, DNase: 0.33, ProK: 0.34 });

            // Create a new row and populate it with integer ratio counts
            const newConfig = {
              dspb: Number(intsObj.DspB) || 0,
              dnase: Number(intsObj.DNase) || 0,
              prok: Number(intsObj.ProK) || 0,
              strategy: payload.fixed_conditions.Addition_Strategy,
              totalTime: payload.fixed_conditions.Reaction_Time,
              dnaseTime: payload.fixed_conditions.DNase_Addition_Time,
              prokTime: payload.fixed_conditions.ProK_Addition_Time,
            };

            // create the new row at the end of the table
            createRow(newConfig);

            // store lastOptimalMix for concentration calculations and future reference
            window.lastOptimalMix = {
              DspB: newConfig.dspb,
              DNase: newConfig.dnase,
              ProK: newConfig.prok,
              total_stock_concentration_mg_ml: result.total_stock_concentration_mg_ml || window.lastOptimalMix?.total_stock_concentration_mg_ml
            };

            // update visuals and trigger prediction for the newly added row
            const createdRow = tableBody.querySelector('tr[data-id="' + experimentCount + '"]');
            if (createdRow) {
              updateRowEstimatedConc(createdRow);
              updateAllVisualizations();
              const predictBtn = createdRow.querySelector('.get-prediction-btn');
              if (predictBtn) {
                getPrediction(createdRow, predictBtn).catch((e) => console.debug('Predict failed', e));
              }
            }
          } catch (error) {
            alert(`Error finding optimal mix: ${error.message}`);
          } finally {
            findOptimalMixBtn.disabled = false;
            findOptimalMixBtn.textContent = 'Find Optimal Mix';
          }
        }
        


        async function renderCoreFeatureImportancePlot() {
          try {
            const res = await fetch(`${API_URL}/feature-importance`);
            if (!res.ok) throw new Error('Could not fetch importance data');
            const data = await res.json();
            const order = ['dspb','dnase','prok','reaction_time'];
            const items = order.filter(k => Object.prototype.hasOwnProperty.call(data, k)).map(k => ({k, v: data[k]}));
            if (items.length === 0) {
              const card = document.getElementById('plot-feature-importance')?.closest('.card');
              if (card) card.remove();
              return;
            }
            const features = items.map(i => i.k);
            const values = items.map(i => i.v);
            const plotData = [{ type: 'bar', x: values.slice().reverse(), y: features.slice().reverse(), orientation: 'h', marker: { color: '#a8c899' } }];
            const layout = { title: 'Feature Importances (Core Features)', xaxis: { title: 'Importance Score (F-score)' }, yaxis: { automargin: true } };
            Plotly.newPlot('plot-feature-importance', plotData, layout, { responsive: true });
          } catch (e) {
            const card = document.getElementById('plot-feature-importance')?.closest('.card');
            if (card) card.remove();
          }
        }

        function updateAllVisualizations() {
          updateSummaryMetrics();
          updatePredictionAnalysis();
          renderTernaryPlot();
          renderTernaryActualPlot();
        }

        function updateSummaryMetrics() {
          const predictions = Array.from(
            document.querySelectorAll('[data-prediction]')
          ).map((el) => parseFloat(el.dataset.prediction));
          const count = predictions.length;
          document.getElementById('summary-count').textContent = count;
          if (count > 0) {
            document.getElementById('summary-best').textContent = `${Math.max(
              ...predictions
            ).toFixed(1)}%`;
            document.getElementById('summary-mean').textContent = `${(
              predictions.reduce((a, b) => a + b, 0) / count
            ).toFixed(1)}%`;
          } else {
            ['summary-best', 'summary-mean'].forEach(
              (id) => (document.getElementById(id).textContent = '-')
            );
          }
        }

        function updatePredictionAnalysis() {
          let totalError = 0,
            validPairs = 0;
          document.querySelectorAll('#table-body tr').forEach((row) => {
            const actualRaw = row.querySelector('.removal-actual')?.dataset.actual;
            const predictedRaw = row.querySelector('[data-prediction]')?.dataset.prediction;
            const actual = actualRaw !== undefined && actualRaw !== null && actualRaw !== '' ? parseFloat(actualRaw) : NaN;
            const predicted = predictedRaw !== undefined && predictedRaw !== null && predictedRaw !== '' ? parseFloat(predictedRaw) : NaN;
            if (!isNaN(actual) && !isNaN(predicted)) {
              totalError += Math.abs(actual - predicted);
              validPairs++;
            }
          });
          document.getElementById('analysis-mae').textContent =
            validPairs > 0 ? `${(totalError / validPairs).toFixed(2)}%` : '-';
        }

        async function renderFeatureImportancePlot() {
          try {
            const res = await fetch(`${API_URL}/feature-importance`);
            if (!res.ok) throw new Error('Could not fetch importance data');
            const data = await res.json();
            const features = Object.keys(data);
            const values = Object.values(data);
            const plotData = [
              {
                type: 'bar',
                x: values.slice(0, 10).reverse(),
                y: features.slice(0, 10).reverse(),
                orientation: 'h',
                marker: { color: '#a8c899' },
              },
            ];
            const layout = {
              title: 'Top 10 Feature Importances',
              xaxis: { title: 'Importance Score (MAE reduction)' },
              yaxis: { automargin: true },
            };
            Plotly.newPlot('plot-feature-importance', plotData, layout, {
              responsive: true,
            });
          } catch (error) {
            document.getElementById(
              'plot-feature-importance'
            ).innerHTML = `<div class="text-center text-red-500 p-4">${error.message}</div>`;
          }
        }

        

        

        function renderTernaryPlot() {
          const rows = document.querySelectorAll('#table-body tr');
          const points = Array.from(rows)
            .map((row) => {
              const dspb = parseFloat(row.querySelector('.ratio-dspb')?.value);
              const dnase = parseFloat(
                row.querySelector('.ratio-dnase')?.value
              );
              const prok = parseFloat(row.querySelector('.ratio-prok')?.value);
              const pred = parseFloat(
                row.querySelector('[data-prediction]')?.dataset.prediction
              );
              const total = dspb + dnase + prok;
              if (total === 0 || isNaN(pred)) return null;
              return {
                a: dspb,
                b: dnase,
                c: prok,
                text: `Predicted: ${pred.toFixed(1)}%`,
                color: pred,
              };
            })
            .filter(Boolean);

          if (points.length === 0) {
            document.getElementById('ternary-plot').innerHTML =
              '<div class="text-center text-gray-400 p-10">Run predictions to see enzyme ratios.</div>';
            return;
          }

          const plotData = [
            {
              type: 'scatterternary',
              mode: 'markers',
              a: points.map((d) => d.a),
              b: points.map((d) => d.b),
              c: points.map((d) => d.c),
              text: points.map((d) => d.text),
              marker: {
                size: 9,
                color: points.map((d) => d.color),
                colorscale: 'YlGn',
                colorbar: { title: 'Predicted<br>Removal (%)' },
              },
            },
          ];
          const layout = {
            title: 'Enzyme Ratio vs. Predicted Removal',
            ternary: {
              sum: 100,
              aaxis: { title: 'Dispersin B' },
              baxis: { title: 'DNase I' },
              caxis: { title: 'Proteinase K' },
            },
          };
          Plotly.newPlot('ternary-plot', plotData, layout, {
            responsive: true,
          });
        }

        function renderTernaryActualPlot() {
          const rows = document.querySelectorAll('#table-body tr');
          const points = Array.from(rows)
            .map((row) => {
              const dspb = parseFloat(row.querySelector('.ratio-dspb')?.value);
              const dnase = parseFloat(
                row.querySelector('.ratio-dnase')?.value
              );
              const prok = parseFloat(row.querySelector('.ratio-prok')?.value);
              const actualRaw = row.querySelector('.removal-actual')?.dataset.actual;
              const actual = actualRaw !== undefined && actualRaw !== null && actualRaw !== '' ? parseFloat(actualRaw) : NaN;
              const total = dspb + dnase + prok;
              if (total === 0 || isNaN(actual)) return null;
              return {
                a: dspb,
                b: dnase,
                c: prok,
                text: `Actual: ${actual.toFixed(1)}%`,
                color: actual,
              };
            })
            .filter(Boolean);

          const target = document.getElementById('ternary-actual-plot');
          if (!target) return;
          if (points.length === 0) {
            target.innerHTML = '<div class="text-center text-gray-400 p-10">Enter Control/Final OD to visualize actual removals.</div>';
            return;
          }

          const plotData = [
            {
              type: 'scatterternary',
              mode: 'markers',
              a: points.map((d) => d.a),
              b: points.map((d) => d.b),
              c: points.map((d) => d.c),
              text: points.map((d) => d.text),
              marker: {
                size: 9,
                color: points.map((d) => d.color),
                colorscale: 'YlOrBr',
                colorbar: { title: 'Actual<br>Removal (%)' },
              },
            },
          ];
          const layout = {
            title: 'Enzyme Ratio vs. Actual Removal (from OD600)',
            ternary: {
              sum: 100,
              aaxis: { title: 'Dispersin B' },
              baxis: { title: 'DNase I' },
              caxis: { title: 'Proteinase K' },
            },
          };
          Plotly.newPlot('ternary-actual-plot', plotData, layout, { responsive: true });
        }

        

        // --- App Initialization ---
        initialData.forEach((c) =>
          createRow({
            ...c,
            dspb: c.dspb || 0,
            dnase: c.dnase || 0,
            prok: c.prok || 0,
          })
        );
        // attempt to apply server-provided optimal mix to first row on startup
        (async function applyServerOptimalOnLoad(){
          try {
            const r = await fetch(`${API_URL}/optimal-mix`);
            if (!r.ok) return;
            const opt = await r.json();
            const first = tableBody.querySelector('tr');
            if (!first) return;
            const intsArr = Array.isArray(opt.integer_counts) ? opt.integer_counts : null;
            const ratiosArr = Array.isArray(opt.ratios) ? opt.ratios : null;
            if (intsArr || ratiosArr) {
              const dspbEl = first.querySelector('.ratio-dspb');
              const dnaseEl = first.querySelector('.ratio-dnase');
              const prokEl = first.querySelector('.ratio-prok');
              if (dspbEl && dnaseEl && prokEl) {
                if (intsArr) {
                  const s = (intsArr[0]||0) + (intsArr[1]||0) + (intsArr[2]||0) || 1;
                  dspbEl.value = String(((intsArr[0]||0)/s).toFixed(2));
                  dnaseEl.value = String(((intsArr[1]||0)/s).toFixed(2));
                  prokEl.value = String(((intsArr[2]||0)/s).toFixed(2));
                  // trigger normalization path to sync sliders
                  dspbEl.dispatchEvent(new Event('change'));
                } else if (ratiosArr) {
                  const intsObj = proportionsToIntegers({ DspB: ratiosArr[0] || 0, DNase: ratiosArr[1] || 0, ProK: ratiosArr[2] || 0 }, 100);
                  const s2 = (intsObj.DSpB||intsObj.DspB||0) + (intsObj.DNase||0) + (intsObj.ProK||0) || 1;
                  const d2 = (intsObj.DspB ?? intsObj.DSpB ?? 0) / s2;
                  const n2 = (intsObj.DNase ?? 0) / s2;
                  const p2 = (intsObj.ProK ?? 0) / s2;
                  dspbEl.value = String(d2.toFixed(2));
                  dnaseEl.value = String(n2.toFixed(2));
                  prokEl.value = String(p2.toFixed(2));
                  dspbEl.dispatchEvent(new Event('change'));
                }
                updateRowEstimatedConc(first);
                updateAllVisualizations();
                const lom = intsArr
                  ? { DspB: intsArr[0] || 0, DNase: intsArr[1] || 0, ProK: intsArr[2] || 0 }
                  : proportionsToIntegers({ DspB: ratiosArr?.[0] || 0, DNase: ratiosArr?.[1] || 0, ProK: ratiosArr?.[2] || 0 }, 100);
                window.lastOptimalMix = { ...lom, total_stock_concentration_mg_ml: opt.total_stock_concentration_mg_ml };
                const predictBtn = first.querySelector('.get-prediction-btn');
                if (predictBtn) getPrediction(first, predictBtn).catch(()=>{});
              }
            }
          } catch (e) {
            console.debug('Could not fetch optimal on load', e);
          }
        })();
        checkApiStatus();
        updateAllVisualizations();
        addRowBtn.addEventListener('click', () =>
          createRow({
            dspb: 0.33,
            dnase: 0.33,
            prok: 0.34,
            strategy: 0,
            totalTime: 24,
            dnaseTime: 0,
            prokTime: 2,
          })
        );
  findOptimalMixBtn.addEventListener('click', findOptimalMix);
  if (exportCsvBtn) exportCsvBtn.addEventListener('click', () => downloadCsv(rowsToCsv()));
  
  setInterval(checkApiStatus, 5000);
      });
    </script>
  </body>
</html>
